<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of getDistance</title>
  <meta name="keywords" content="getDistance">
  <meta name="description" content="getDistance returns the distance between two locations in the suface of the Earth.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../index.html">Home</a> &gt;  <a href="index.html">src</a> &gt; getDistance.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../index.html"><img alt="<" border="0" src="../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for src&nbsp;<img alt=">" border="0" src="../right.png"></a></td></tr></table>-->

<h1>getDistance
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>getDistance returns the distance between two locations in the suface of the Earth.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function [ d ] = getDistance(Y0, X0, Y1, X1, method) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment">getDistance returns the distance between two locations in the suface of the Earth.
   
%--------------------------------------------------------------------------------------------------
   @desc This function computes the distance between two locations in the suface of the Earth.
   
   The default datum used for calculations is the WGS-84 but support for more datums
   could be developed in future releases.
   
   Both UTM and geographical coordinates could be used, taking into account that in UTM
   case, both locations shall be in the same UTM Zone, in order to avoid lacks in the accuracy.
   
   Supports the use of vectors in the input coordinates, both UTM and geographical.
   
   Vincenty method gives more precise results but may fail to converge in the case of
   antipodal points and also in random pairs of points.

   If Vincenty formula fails to converge, then a warning is displayed and the value is
   trapped to the one of the Haversine formula.
   
%--------------------------------------------------------------------------------------------------
   @ref http://www.movable-type.co.uk/scripts/latlong.html
   @ref http://www.movable-type.co.uk/scripts/latlong-vincenty.html
   @ref http://www.movable-type.co.uk/scripts/latlong.html

%--------------------------------------------------------------------------------------------------
   The inputs for this function are:
   
   - @iparam [float] Y0: initial latitude or Northing {deg. or m}
   - @iparam [float] X0: initial longitude or Easting {deg. or m}
   - @iparam [float] Y1: final latitude or Northing {deg. or m}
   - @iparam [float] X1: final longitude or Easting {deg. or m}
   
   - @iparam [String] method: string that defines the method to be used in the calculations
       -&gt; 'Hav: Haversine distance (only for Geo) (Default)  
       -&gt; 'Vin': Vincenty distance (only for Geo)
       -&gt; 'Pyt': Pythagarus distance (only for UTM)
       -&gt; 'Rh': Rhumb lines distance (only for Geo)
       -&gt; 'Hav2': Haversine distance computed by an aproximation of the Vincenty formula
       -&gt; that is accurate for all locations (only for Geo)      
   
%--------------------------------------------------------------------------------------------------
   The output of this function is:

   - @oparam [float] d: distance between locations in meters {m}

%--------------------------------------------------------------------------------------------------
   ** @author Andrés Ferreiro González (@aferreiro)
   ** @company Galician Research And Development Center In Advanced Telecommunications (GRADIANT)
   ** @date 16/02/2017
   ** @version 1.2
%--------------------------------------------------------------------------------------------------
%%-------------------------------------------------------------------------------------------------</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="computeGrid.html" class="code" title="function [ Grid, flag, varargout ] = computeGrid( polygon, photoParams, StartPos, cryteria )">computeGrid</a>	computeGrid computes the grid required to cover the specified polygon.</li><li><a href="getAngleOfLongestSide.html" class="code" title="function [ angleLS, distLS, index ] = getAngleOfLongestSide( lats, lons, mode )">getAngleOfLongestSide</a>	getAngleOfLongestSide gets the angle of the longest side of a plygon defined by its</li><li><a href="getPolyBounds.html" class="code" title="function [ PolyBounds ] = getPolyBounds(polyx, polyy)">getPolyBounds</a>	getPolyBounds returns the bounds of a polygon defined by its vertices X - Y coordinates.</li></ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [ d ] = getDistance(Y0, X0, Y1, X1, method)</a>
0002 <span class="comment">%getDistance returns the distance between two locations in the suface of the Earth.</span>
0003 <span class="comment">%</span>
0004 <span class="comment">%%--------------------------------------------------------------------------------------------------</span>
0005 <span class="comment">%   @desc This function computes the distance between two locations in the suface of the Earth.</span>
0006 <span class="comment">%</span>
0007 <span class="comment">%   The default datum used for calculations is the WGS-84 but support for more datums</span>
0008 <span class="comment">%   could be developed in future releases.</span>
0009 <span class="comment">%</span>
0010 <span class="comment">%   Both UTM and geographical coordinates could be used, taking into account that in UTM</span>
0011 <span class="comment">%   case, both locations shall be in the same UTM Zone, in order to avoid lacks in the accuracy.</span>
0012 <span class="comment">%</span>
0013 <span class="comment">%   Supports the use of vectors in the input coordinates, both UTM and geographical.</span>
0014 <span class="comment">%</span>
0015 <span class="comment">%   Vincenty method gives more precise results but may fail to converge in the case of</span>
0016 <span class="comment">%   antipodal points and also in random pairs of points.</span>
0017 <span class="comment">%</span>
0018 <span class="comment">%   If Vincenty formula fails to converge, then a warning is displayed and the value is</span>
0019 <span class="comment">%   trapped to the one of the Haversine formula.</span>
0020 <span class="comment">%</span>
0021 <span class="comment">%%--------------------------------------------------------------------------------------------------</span>
0022 <span class="comment">%   @ref http://www.movable-type.co.uk/scripts/latlong.html</span>
0023 <span class="comment">%   @ref http://www.movable-type.co.uk/scripts/latlong-vincenty.html</span>
0024 <span class="comment">%   @ref http://www.movable-type.co.uk/scripts/latlong.html</span>
0025 <span class="comment">%</span>
0026 <span class="comment">%%--------------------------------------------------------------------------------------------------</span>
0027 <span class="comment">%   The inputs for this function are:</span>
0028 <span class="comment">%</span>
0029 <span class="comment">%   - @iparam [float] Y0: initial latitude or Northing {deg. or m}</span>
0030 <span class="comment">%   - @iparam [float] X0: initial longitude or Easting {deg. or m}</span>
0031 <span class="comment">%   - @iparam [float] Y1: final latitude or Northing {deg. or m}</span>
0032 <span class="comment">%   - @iparam [float] X1: final longitude or Easting {deg. or m}</span>
0033 <span class="comment">%</span>
0034 <span class="comment">%   - @iparam [String] method: string that defines the method to be used in the calculations</span>
0035 <span class="comment">%       -&gt; 'Hav: Haversine distance (only for Geo) (Default)</span>
0036 <span class="comment">%       -&gt; 'Vin': Vincenty distance (only for Geo)</span>
0037 <span class="comment">%       -&gt; 'Pyt': Pythagarus distance (only for UTM)</span>
0038 <span class="comment">%       -&gt; 'Rh': Rhumb lines distance (only for Geo)</span>
0039 <span class="comment">%       -&gt; 'Hav2': Haversine distance computed by an aproximation of the Vincenty formula</span>
0040 <span class="comment">%       -&gt; that is accurate for all locations (only for Geo)</span>
0041 <span class="comment">%</span>
0042 <span class="comment">%%--------------------------------------------------------------------------------------------------</span>
0043 <span class="comment">%   The output of this function is:</span>
0044 <span class="comment">%</span>
0045 <span class="comment">%   - @oparam [float] d: distance between locations in meters {m}</span>
0046 <span class="comment">%</span>
0047 <span class="comment">%%--------------------------------------------------------------------------------------------------</span>
0048 <span class="comment">%   ** @author Andrés Ferreiro González (@aferreiro)</span>
0049 <span class="comment">%   ** @company Galician Research And Development Center In Advanced Telecommunications (GRADIANT)</span>
0050 <span class="comment">%   ** @date 16/02/2017</span>
0051 <span class="comment">%   ** @version 1.2</span>
0052 <span class="comment">%%--------------------------------------------------------------------------------------------------</span>
0053 <span class="comment">%%%-------------------------------------------------------------------------------------------------</span>
0054 
0055 
0056 <span class="comment">% DATUM PARAMETERS (WGS-84)</span>
0057 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0058 MAJOR_SEMIAXIS = 6378137.000;                                         <span class="comment">% Major semiaxis</span>
0059 MINOR_SEMIAXIS = 6.356752314245179e+06;
0060 FLATTENING = 1 / 298.257223563;                                       <span class="comment">% Flattening</span>
0061 
0062 
0063 MEAN_RADIUS = 6.371008771415059e+06;                                  <span class="comment">% mean Earth Radius [m]</span>
0064 
0065 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0066 
0067 flag = 0;
0068 
0069 
0070 <span class="keyword">if</span> nargin &lt; 4
0071     
0072         error(<span class="string">'Not enough input arguments. Type &quot;help getDistance&quot; in the command prompt for more info about function usage.'</span>);
0073         
0074 <span class="keyword">elseif</span> nargin &gt; 5
0075     
0076         error(<span class="string">'Too many input arguments. Type &quot;help getDistance&quot; in the command prompt for more info about function usage.'</span>);
0077             
0078             
0079 <span class="keyword">end</span>
0080 
0081 
0082 <span class="keyword">if</span> nargin == 4
0083     
0084     method = <span class="string">'Hav'</span>;
0085 <span class="keyword">end</span>
0086 
0087 <span class="keyword">switch</span>(method)
0088     
0089     <span class="keyword">case</span> <span class="string">'Hav'</span>
0090         
0091         <span class="comment">% CONVERSION TO RADIANS</span>
0092         <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0093         lat1rad=Y0.*pi./180;
0094         lat2rad=Y1.*pi./180;
0095         lon1rad=X0.*pi./180;
0096         lon2rad=X1.*pi./180;
0097 
0098         deltaLat=lat2rad-lat1rad;
0099         deltaLon=lon2rad-lon1rad;
0100 
0101         <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0102         
0103         <span class="comment">% HAVERSINE DISTANCE COMPUTATION</span>
0104         <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0105         ds = 2*asin(sqrt( sin( (deltaLat)./2 ).^2 + cos(lat1rad).*cos(lat2rad).*sin( deltaLon./2 ).^2));
0106        
0107         d = MEAN_RADIUS.*ds;
0108         
0109         <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0110         
0111         
0112     <span class="keyword">case</span> <span class="string">'Hav2'</span>
0113         
0114         <span class="comment">% CONVERSION TO RADIANS</span>
0115         <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0116         lat1rad=Y0.*pi./180;
0117         lat2rad=Y1.*pi./180;
0118         lon1rad=X0.*pi./180;
0119         lon2rad=X1.*pi./180;
0120 
0121         deltaLat=lat2rad-lat1rad;
0122         deltaLon=lon2rad-lon1rad;
0123 
0124         <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0125         
0126         a = sqrt( ( cos(lat2rad).*sin(deltaLon) ).^2 + ( cos(lat1rad).*sin(lat2rad) - sin(lat1rad).*cos(lat2rad).*cos(deltaLon) ).^2 );
0127         b = sin(lat1rad).*sin(lat2rad) + cos(lat1rad).*cos(lat2rad).*cos(deltaLon);
0128         
0129         ds = atan2(a,b);
0130         
0131         d = MEAN_RADIUS.*ds;
0132         
0133         
0134     <span class="keyword">case</span> <span class="string">'Vin'</span>
0135         
0136         <span class="comment">% CONVERSION TO RADIANS</span>
0137         <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0138         lat1rad=Y0.*pi./180;
0139         lat2rad=Y1.*pi./180;
0140         lon1rad=X0.*pi./180;
0141         lon2rad=X1.*pi./180;
0142 
0143         deltaLat=lat2rad-lat1rad;
0144         deltaLon=lon2rad-lon1rad;
0145 
0146         <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0147         
0148         <span class="comment">% PRELIMINARY CALCULATIONS</span>
0149         <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0150         tanU1 = (1 - FLATTENING).*tan(lat1rad);
0151         tanU2 = (1 - FLATTENING).*tan(lat2rad);
0152         
0153         
0154         cosU1 = 1./( sqrt( 1 + tanU1.^2 ) );
0155         cosU2 = 1./( sqrt( 1 + tanU2.^2 ) );
0156         
0157         sinU1 = tanU1.*cosU1;
0158         sinU2 = tanU2.*cosU2;
0159         
0160         <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0161         
0162         
0163         <span class="comment">% ITERATIVE PROCESS</span>
0164         <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0165         lamb = deltaLon;                            <span class="comment">% Initial approximation</span>
0166         lambit =  500;                              <span class="comment">% intitial iterator</span>
0167         itLimit = 100;                              <span class="comment">% Iteration limit</span>
0168         
0169         
0170         <span class="keyword">while</span>( abs(lamb - lambit) &gt; 1e-12 &amp;&amp; itLimit &gt; 0)
0171             
0172             sinl = sin(lamb);
0173             cosl = cos(lamb);
0174             
0175             sinsig = sqrt( ( cosU2.*sinl ).^2 + ( cosU1.*sinU2 - sinU1.*cosU2.*cosl).^2 );
0176             
0177             <span class="keyword">if</span> sinsig == 0
0178                 
0179                 error(<span class="string">'The points to evaluate are the same!'</span>);
0180                 
0181             <span class="keyword">end</span>
0182             
0183             cosig = ( sinU1.*sinU2 ) + ( cosU1.*cosU2.*cosl );
0184             sig = atan2(sinsig, cosig);
0185             
0186             sinal = cosU1.*cosU2.*sinl./sinsig;
0187             
0188             cosinsq = 1 - sinal.*2;
0189             cos2sig = cosig - 2.*sinU1*sinU2./cosinsq;
0190             
0191             <span class="keyword">if</span> isnan(cos2sig) 
0192                 
0193                 cos2sig = 0;
0194             <span class="keyword">end</span>
0195             
0196             C = (FLATTENING/16).*cosinsq.*(4 + FLATTENING.*( 4 - 3.*cosinsq ) );
0197             
0198             lambit = lamb;
0199             
0200             lamb = deltaLon + (1 - C).*FLATTENING.*sinal.*( sig + C.*sinsig.*( cos2sig + C.*cosig.*( -1 + 2*cos2sig.^2 ) ) );
0201             
0202             itLimit = itLimit - 1;          
0203             
0204         <span class="keyword">end</span>
0205         
0206         
0207         <span class="keyword">if</span> itLimit == 0
0208             
0209             warning(<span class="string">'Vincenty Formula failed to converge'</span>);
0210             
0211             flag = 1;
0212             
0213         <span class="keyword">else</span>
0214         
0215         uSq = cosinsq.*( MAJOR_SEMIAXIS^2 - MINOR_SEMIAXIS^2)./( MINOR_SEMIAXIS^2 );
0216         
0217         A = 1 + (uSq/16384).*( 4096 + uSq.*( -768.*uSq.*( 320 - 175.*uSq ) ) );
0218         
0219         B = (uSq./1024).*( 256 + uSq.*( -128 + uSq.*( 74 - 47.*uSq ) ) );
0220         
0221         dsig = B.*sinsig.*( cos2sig +(B./4).*(cosig.*( -1 + 2.*cos2sig.^2 ) - (B./6).*cos2sig.*( -3 + 4.*sinsig.^2 ).*( -3 + 4.*cos2sig.^2 ) ) );
0222         
0223         d = MINOR_SEMIAXIS.*A.*( sig - dsig );
0224         
0225         <span class="keyword">end</span>
0226         
0227     <span class="keyword">case</span> <span class="string">'Pyt'</span>
0228         
0229         d = sqrt( ( X1 - X0 ).^2 + ( Y1 - Y0 ).^2 );
0230         
0231     <span class="keyword">case</span> <span class="string">'Rh'</span>
0232         
0233         <span class="comment">% CONVERSION TO RADIANS</span>
0234         <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0235         lat1rad=Y0.*pi./180;
0236         lat2rad=Y1.*pi./180;
0237         lon1rad=X0.*pi./180;
0238         lon2rad=X1.*pi./180;
0239 
0240         deltaLat=lat2rad-lat1rad;
0241         deltaLon=lon2rad-lon1rad;
0242 
0243         <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0244         
0245         dPhi = log( tan( pi/4 + lat2rad./2 )./tan( pi/4 + lat1rad./2 ) );
0246         
0247         <span class="keyword">if</span> abs(dPhi) &gt; 10e-12
0248             
0249             q = deltaLat ./ dPhi;
0250             
0251         <span class="keyword">else</span>
0252             
0253             q = cos(lat1rad);
0254             
0255         <span class="keyword">end</span>
0256         
0257         <span class="keyword">if</span> abs(deltaLon) &gt; pi
0258             
0259             <span class="keyword">if</span> deltaLon &gt; 0
0260                 
0261                 deltaLon = -(2*pi - deltaLon);
0262                 
0263             <span class="keyword">else</span>
0264                 
0265                 deltaLon = 2.*pi + deltaLon;
0266             <span class="keyword">end</span>
0267         <span class="keyword">end</span>
0268         
0269         delta = sqrt( deltaLat.^2 + (q.^2).*deltaLon.^2 );
0270         
0271         d = MEAN_RADIUS.*delta;
0272         
0273          
0274             
0275     <span class="keyword">otherwise</span>
0276         
0277         error(<span class="string">'Unrecognized computation method. Type &quot;help getDistance&quot; in the command prompt for more info about function usage'</span>);
0278         
0279 <span class="keyword">end</span>    
0280 
0281 <span class="comment">% TRAP WHEN VINCENTY METHOD FAILS TO CONVERGE</span>
0282 
0283 
0284 <span class="keyword">if</span> flag == 1
0285     
0286         <span class="comment">% CONVERSION TO RADIANS</span>
0287         <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0288         lat1rad=Y0.*pi./180;
0289         lat2rad=Y1.*pi./180;
0290         lon1rad=X0.*pi./180;
0291         lon2rad=X1.*pi./180;
0292 
0293         deltaLon=lon2rad-lon1rad;
0294 
0295         <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0296        
0297         a = sqrt( ( cos(lat2rad).*sin(deltaLon) ).^2 + ( cos(lat1rad).*sin(lat2rad) - sin(lat1rad).*cos(lat2rad).*cos(deltaLon) ).^2 );
0298         b = sin(lat1rad).*sin(lat2rad) + cos(lat1rad).*cos(lat2rad).*cos(deltaLon);
0299         
0300         ds = atan2(a,b);
0301         
0302         d = MEAN_RADIUS.*ds;
0303 <span class="keyword">end</span>
0304             
0305 <span class="keyword">end</span>
0306</pre></div>
<hr><address>Generated on Sat 25-Mar-2017 19:17:00 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>